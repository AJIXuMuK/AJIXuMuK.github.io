---
layout: post
title: Office UI Fabric React Grouped DetailsList - Display Tree-like Hierarchy
date: '2020-02-12T14:42:00.000-08:00'
author: Alex Terentiev
tags:
- Office UI Fabric
- DetalisList
- SharePoint Framework
- Office 365
- Grid
- SharePoint
- Office UI Fabric React
- SPFx
- SPFx Web Parts
- OUIFR
- Tree
- Hierarchy
modified_time: '2020-02-12T14:49:06.622-08:00'
thumbnail: https://4.bp.blogspot.com/-BqIaHrh_5LI/XkRwkkoEGGI/AAAAAAAABfk/8Gq6rPtW-1osvaNXeBFGWgHpUqzj2EQzwCLcBGAsYHQ/s72-c/Screen%2BShot%2B2020-02-12%2Bat%2B1.04.31%2BPM.png
blogger_id: tag:blogger.com,1999:blog-3066084330774405472.post-5476940037224468383
blogger_orig_url: http://blog.aterentiev.com/2020/02/office-ui-fabric-react-grouped.html
---

<style>.code { font-family: Consolas, "courier new", "courier", monospace; font-size: 13px; } </style>This blog post describes how to implement tree-like hierarchy using Office UI Fabric React (OUIFR) Grouped DetailsList component.<br />We'll be working with a hierarchy similar to the one displayed on the image below:<br /><a href="https://4.bp.blogspot.com/-BqIaHrh_5LI/XkRwkkoEGGI/AAAAAAAABfk/8Gq6rPtW-1osvaNXeBFGWgHpUqzj2EQzwCLcBGAsYHQ/s1600/Screen%2BShot%2B2020-02-12%2Bat%2B1.04.31%2BPM.png" imageanchor="1"><img border="0" data-original-height="258" data-original-width="350" src="https://4.bp.blogspot.com/-BqIaHrh_5LI/XkRwkkoEGGI/AAAAAAAABfk/8Gq6rPtW-1osvaNXeBFGWgHpUqzj2EQzwCLcBGAsYHQ/s1600/Screen%2BShot%2B2020-02-12%2Bat%2B1.04.31%2BPM.png" /></a><br /><h2>TL;DR</h2>Office UI Fabric React (OUIFR) DetailsList ignores (doesn't render) items for the group if it (the group) has subgroups. As a result for a tree-like hierarchy - some of the items could be lost.<br /><a href="#solution">Jump to solution</a>.  <br /><a name='more'></a><h2>The Problem</h2>We need to display a hierarchical grid, or grouped grid where each node (group) can have child nodes as well as leaf items.<br />For the hierarchy from the picture above we want to see something like this:<br /><a href="https://1.bp.blogspot.com/-GqJDMUOHANQ/XkRxRjXBzhI/AAAAAAAABfs/TNYDb-5JgSYFy_0F7oGF7Bl_YRnvQFV8QCLcBGAsYHQ/s1600/Screen%2BShot%2B2020-02-12%2Bat%2B1.01.52%2BPM.png" imageanchor="1"><img border="0" data-original-height="713" data-original-width="752" src="https://1.bp.blogspot.com/-GqJDMUOHANQ/XkRxRjXBzhI/AAAAAAAABfs/TNYDb-5JgSYFy_0F7oGF7Bl_YRnvQFV8QCLcBGAsYHQ/s1600/Screen%2BShot%2B2020-02-12%2Bat%2B1.01.52%2BPM.png" width="600" /></a><br />So, we have a root level node <b>code</b> that contains leaf item <b>index.ts</b> and two subgroups with their own items: <b>components</b> and <b>webparts</b>.<br />As we're developing SharePoint Framework solution (of course - this blog is about O365 and SharePoint =)) it would be great to use OUIFR <span class="code">DetailsList</span> component to display grouped grid with a header. <br /><h2>Initial Implementation</h2>Initial implementation for our component will be pretty simple.<br />We need to define our leaf item interface: <br /><pre class="brush: typescript;">export interface IItem {<br />  key: string;<br />  title: string;<br />}<br /></pre>And our node interface: <br /><pre class="brush: typescript;">export interface INode extends IItem {<br />  items?: IItem[];<br />  children?: INode[];<br />}<br /></pre>Using these two interfaces we can define our hierarchy like that: <br /><pre class="brush: typescript;">private readonly _nodes: INode[] = [{<br />    key: 'code',<br />    title: 'code',<br />    items: [{<br />      key: 'index',<br />      title: 'index.ts'<br />    }],<br />    children: [{<br />      key: 'components',<br />      title: 'components',<br />      items: [{<br />        key: 'component',<br />        title: 'Component.tsx'<br />      }]<br />    }, {<br />      key: 'webparts',<br />      title: 'webparts',<br />      items: [{<br />        key: 'scss',<br />        title: 'WebPart.module.scss'<br />      }, {<br />        key: 'ts',<br />        title: 'WebPart.ts'<br />      }]<br />  }]<br />}];<br /></pre> Now, we need to process our hierarchy to construct flat array of <span class="code">IItem</span> items and array of <span class="code"><a href="https://developer.microsoft.com/en-us/fabric#/controls/web/groupedlist#IGroup" target="_blank">IGroup</a></span> groups. This arrays will be used by <span class="code">DetailsList</span> component to display <a href="https://developer.microsoft.com/en-us/fabric#/controls/web/detailslist/grouped" target="_blank">grouped list</a>.<br />Let's assume that the hierarchy is passed in the <span class="code">props</span> of our component: <pre class="brush: typescript;"><br />export interface IOuifrGroupedDetailsListProps {<br />  nodes: INode[];<br />}<br /></pre>Then, we can used the methods below to process the hierarchy and save results to the state: <pre class="brush: typescript;"><br />/**<br /> * Gets flat items array and groups array based on the hierarchy from the props<br /> */<br />private _getItemsAndGroups = (props: IOuifrGroupedDetailsListProps): void => {<br />  const nodes = props.nodes;<br />  const items: IItem[] = [];<br />  const groups: IGroup[] = [];<br /><br />  // processing all the nodes recursively<br />  this._processNodes(nodes, groups, items, 0);<br /><br />  // setting the state<br />  this.setState({<br />    groups: groups,<br />    items: items<br />  });<br />}<br /><br />/**<br /> * Recursively process hierarchy's nodes to build groups and add items to the flat array<br /> */<br />private _processNodes = (nodeItems: INode[] | undefined, groups: IGroup[], items: IItem[], level: number): void => {<br />  // end of recursion<br />  if (!nodeItems || !nodeItems.length) {<br />    return;<br />  }<br /><br />  // processing current level of the tree<br />  nodeItems.forEach(nodeItem =&gt; {<br />    const newGroup: IGroup = {<br />      key: nodeItem.key,<br />      name: nodeItem.title,<br />      startIndex: items.length,<br />      count: 0,<br />      children: [],<br />      level: level, // level is incremented on each call of the recursion<br />      data: nodeItem // storing initial INode instance in the group's data<br />    };<br /><br />    groups.push(newGroup);<br />    if (nodeItem.items && nodeItem.items.length) {<br /><br />      // adding items to the flat array<br />      items.push(...nodeItem.items);<br />    }<br /><br />    // processing child nodes<br />    this._processNodes(nodeItem.children, newGroup.children!, items, level + 1);<br /><br />    // current group count is a sum of group's leaf items and leaf items in all child nodes<br />    newGroup.count = items.length - newGroup.startIndex;<br />  });<br />}<br /></pre> And now we can render the <span class="code">DetailsList</span> using values from the state: <pre class="brush: typescript;"><br />public render(): React.ReactElement&lt;IOuifrGroupedDetailsListProps&gt; {<br />  const {<br />    items,<br />    groups<br />  } = this.state;<br /><br />  return (<br />    &lt;div className={styles.ouifrGroupedDetailsList}&gt;<br />      &lt;DetailsList<br />          columns={this._columns}<br />          items={items || []}<br />          groups={groups}<br />        /&gt;<br />    &lt;/div&gt;<br />  );<br />}<br /></pre>If we look at the rendered result, we'll see such a list:<br /><a href="https://3.bp.blogspot.com/-tIirW9f-TeE/XkR4EOf7R-I/AAAAAAAABgI/Ho8HKXsiTPcx_IZ7B-f0nUG95tTGQkrIwCLcBGAsYHQ/s1600/Screen%2BShot%2B2020-02-12%2Bat%2B2.10.30%2BPM.png" imageanchor="1" ><img border="0" src="https://3.bp.blogspot.com/-tIirW9f-TeE/XkR4EOf7R-I/AAAAAAAABgI/Ho8HKXsiTPcx_IZ7B-f0nUG95tTGQkrIwCLcBGAsYHQ/s1600/Screen%2BShot%2B2020-02-12%2Bat%2B2.10.30%2BPM.png" data-original-width="996" data-original-height="570" width="600" /></a><br />The problem here is we're missing <b>index.ts</b> leaf item in the <b>code</b> group. So, it's kinda data loss situation from user perspective.<br />The reason for that, as mentioned above, is <span class="code">DetailsList</span> component ignores group's items if there are subgroups. <a name="solution"></a><h2>The Solution</h2>The solution here consists of two parts.<br />First, we'll add "fake" subgroup and place all the missing leaf items in it. For our sample we'll add <b>fake</b> subgroup to <b>code</b> group and move <b>index.ts</b> into it: <pre class="brush: typescript;"><br />private _processNodes = (nodeItems: INode[] | undefined, groups: IGroup[], items: IItem[], level: number): void => {<br />  // ...<br /><br />  // processing current level of the tree<br />  nodeItems.forEach(nodeItem =&gt; {<br />    // ...<br />    groups.push(newGroup);<br />    if (nodeItem.items && nodeItem.items.length) {<br />      // adding fake group with no data<br />      if (nodeItem.children && nodeItem.children.length) {<br />        newGroup.children!.push({<br />          key: `${nodeItem.key}-fake`,<br />          name: '',<br />          startIndex: items.length,<br />          count: nodeItem.items.length,<br />          level: level<br />        });<br />      }<br /><br />      // adding items to the flat array<br />      items.push(...nodeItem.items);<br />    }<br /><br />    // ...<br />  });<br />}<br /></pre>The fake group doesn't have <span class="code">data</span> as there is no actual <span class="code">INode</span> item related to it.<br />Now our component looks like that:<br /><a href="https://1.bp.blogspot.com/-4iT9kIXYpmY/XkR79MKh8JI/AAAAAAAABgk/VuetaolJ5D4ZgcgiYWEd3bc3ynv7a59NgCLcBGAsYHQ/s1600/Screen%2BShot%2B2020-02-12%2Bat%2B2.27.42%2BPM.png" imageanchor="1" ><img border="0" src="https://1.bp.blogspot.com/-4iT9kIXYpmY/XkR79MKh8JI/AAAAAAAABgk/VuetaolJ5D4ZgcgiYWEd3bc3ynv7a59NgCLcBGAsYHQ/s1600/Screen%2BShot%2B2020-02-12%2Bat%2B2.27.42%2BPM.png" data-original-width="1154" data-original-height="793" width="600" /></a><br />The <b>index.ts</b> item is there, but, as expected, it is displayed as a child of <b>fake</b> group.<br /><br />The second step of the solution is to override rendering of group's header and hide the header for any fake group.<br />As we know, fake groups don't have <span class="code">data</span> assigned, so we can use it to determine if the group is fake.<br />And we can override group's header rendering using <span class="code">groupProps</span> property of the <span class="code">DetailsList</span>: <pre class="brush: typescript;"><br />public render(): React.ReactElement&lt;IOuifrGroupedDetailsListProps&gt; {<br />  // ...<br />  return (<br />    &lt;div className={ styles.ouifrGroupedDetailsList }&gt;<br />      &lt;DetailsList<br />          /* ... */<br />          groupProps={{ "{{" }}<br />            onRenderHeader: this._onRenderGroupHeader,<br />            isAllGroupsCollapsed: groups ? groups.filter(gr =&gt; !gr.isCollapsed).length === 0 : true,<br />            collapseAllVisibility: CollapseAllVisibility.visible<br />          }}<br />      /&gt;<br />    &lt;/div&gt;<br />  );<br />}<br /><br />private _onRenderGroupHeader = (props: IDetailsGroupDividerProps, _defaultRender?: IRenderFunction&lt;IDetailsGroupDividerProps&gt;): JSX.Element =&gt; {<br />  // for fake groups - return empty element<br />  if (!props.group!.data) {<br />    return &lt;&gt;&lt;/&gt;;<br />  }<br /><br />  // default rendering for "real" groups<br />  return _defaultRender(props);<br />}<br /></pre>After these changes we'll see the result we actually want. Moreover, all events, including collapsing/expanding will still work as expected!<br /><br />You can find full sample code for this post <a href="https://github.com/AJIXuMuK/SPFx/tree/master/ouifr-grouped-details-list" target="_blank">here</a>. <br /><br />That's all for today!<br />Have fun!