---
layout: post
title: 'SPFx. Client Web Part Property Pane Dependent Properties. Part III: Styling
  Dependent Properties Control as Office UI Fabric dropdowns. Knockout version.'
date: '2016-10-27T22:18:00.000-07:00'
author: Alex Terentiev
tags:
- JavaScript
- SharePoint Online
- SPFx
- Client Web Part
- SharePoint Framework
- Future of SharePoint
- SharePoint
modified_time: '2016-10-28T12:51:05.676-07:00'
thumbnail: https://3.bp.blogspot.com/-rlde-CtbnBM/WBOnktZTdbI/AAAAAAAAAa8/8SkI-6Grj4gnW0i3l8s7_ncUcLNFueRdACLcB/s72-c/Screen%2BShot%2B2016-10-28%2Bat%2B12.31.15%2BPM.png
blogger_id: tag:blogger.com,1999:blog-3066084330774405472.post-7269803676887840015
blogger_orig_url: http://blog.aterentiev.com/2016/10/spfx-client-web-part-property-pane_27.html
---

This is the last post of three that explain how to add dependent properties to Client Web Part Property Pane.<br />As an example of such properties I decided to use Lists dropdown and Views dropdown. Views dropdown is populated based on selected List. As a result of these three posts we'll have a fully working web part with ability to select List View in Property Pane:<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-rlde-CtbnBM/WBOnktZTdbI/AAAAAAAAAa8/8SkI-6Grj4gnW0i3l8s7_ncUcLNFueRdACLcB/s1600/Screen%2BShot%2B2016-10-28%2Bat%2B12.31.15%2BPM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="312" src="https://3.bp.blogspot.com/-rlde-CtbnBM/WBOnktZTdbI/AAAAAAAAAa8/8SkI-6Grj4gnW0i3l8s7_ncUcLNFueRdACLcB/s640/Screen%2BShot%2B2016-10-28%2Bat%2B12.31.15%2BPM.png" width="640" /></a></div><br />Here is a content of 3 posts:<br /><ol><li><a href="http://tricky-sharepoint.blogspot.com/2016/10/spfx-client-web-part-property-pane.html" target="_blank">SPFx. Client Web Part Property Pane Dependent Properties. Part I: Preparation.</a></li><li><a href="http://tricky-sharepoint.blogspot.com/2016/10/spfx-client-web-part-property-pane_26.html" target="_blank">SPFx. Client Web Part Property Pane Dependent Properties. Part II: Dependent Properties Control.</a></li><li>SPFx. Client Web Part Property Pane Dependent Properties. Part III: Styling Dependent Properties Control as Office UI Fabric dropdowns. Knockout version. (current post)</li></ol><div>All the code is available on GitHub (<a href="https://github.com/AJIXuMuK/SPFx/tree/master/dep-props-custom-class" target="_blank">https://github.com/AJIXuMuK/SPFx/tree/master/dep-props-custom-class</a>)<br />I'm using Visual Studio Code IDE for the tutorial.<br /><a name='more'></a><br />This post describes creation of custom Knockout bindings, custom Knockout components and styling your components in Office UI Fabric manner.<br /><br />In previous post we created a custom field that consists of two dependent dropdowns. Everything works good but looks not so good. It would be much better if our dropdowns look similar to <a href="https://dev.office.com/fabric#/components/dropdown" target="_blank">Office UI Fabric Dropdown</a>. Unfortunately there is no Knockout version of Office UI Fabric Dropdown and a Dropdown from Fabric JS is pretty static - it creates <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&lt;ul&gt;</span>&nbsp;markup based on a <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&lt;select&gt;.</span>&nbsp;But if you change something in your select dynamically it won't reflect UL until you recreate the Fabric JS dropdown.<br />So let's create our own Knockout.js component styled as Office UI Fabric Dropdown. You can find documentation on Knockout components <a href="http://knockoutjs.com/documentation/component-overview.html" target="_blank">here</a>&nbsp;so I won't spend time to describe it deeply. In few words we need to create a view, a viewmodel and register the component to be able to use it in our app.<br />First of all, we need to create some interface that will describe a single dropdown item. We need value, text and selected flag to describe an item (/webparts/depProps/components/dropdown/viewmodel): <br /><pre class="brush: typescript;">/**<br /> * Dropdown option item<br /> */<br />export interface IDropdownOption {<br />  value: string | number;<br />  text: string;<br />  selected: boolean;<br />}<br /></pre><br />It also would be great if our component's bindings look similar to standard <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&lt;select&gt;</span>&nbsp;bindings. It means that we could provide<br /><ul><li>options - observable array of dropdown items</li><li>optionsCaption - dummy option to prefix a list of dropdown items</li><li>value - selected value</li><li>disabled - flag if a dropdown disabled or not</li></ul><div>in a manner like</div><pre class="brush: html;">&lt;our-component params="options: listOfOptions, optionsCaption: caption, value: currentValue, disabled: isDisabled"&gt;&lt;/our-component&gt;<br /></pre><div>Based on the above we can create an interface that describes parameters of our component (/webparts/depProps/components/dropdown/viewmodel): <br /><pre class="brush: typescript;">/**<br /> * Parameters that can be provided to Dropdown component<br /> */<br />export interface IDropdownViewModelParams {<br />  /**<br />   * options collection as KnockoutObservableArray<br />   */<br />  options: KnockoutObservableArray<idropdownoption>;<br />  /**<br />   * Dropdown empty element text and text of Dropdown label<br />   */<br />  optionsCaption: string;<br />  /**<br />   * Selected value<br />   */<br />  value: KnockoutObservable<string>;<br /><br />  /**<br />   * Is Dropdown disabled<br />   */<br />  disabled?: KnockoutObservable<boolean>;<br />}<br /></boolean></string></idropdownoption></pre><br /></div><div>Now let's look at Office UI Fabric Dropdown markup to understand what we need to implement in our component's view:</div><pre class="brush: html;">&lt;div&gt;<br />  &lt;label class="ms-Label"&gt;Label goes here&lt;/label&gt;<br />  &lt;div class="ms-Dropdown"&gt;<br />    &lt;span class="ms-Dropdown-title"&gt;Selected Option&lt;/span&gt;<br />    &lt;i class="ms-Dropdown-caretDown ms-Icon ms-Icon--ChevronDown"&gt;&lt;/i&gt;<br />    &lt;ul class="ms-Dropdown-items"&gt;<br />      &lt;li class="ms-Dropdown-item" role="option"&gt;Option 1&lt;/li&gt;<br />      &lt;li class="ms-Dropdown-item"&gt;Option 2&lt;/li&gt;<br />      &lt;!-- etc. --&gt;<br />    &lt;/ul&gt;<br />  &lt;/div&gt;<br />&lt;/div&gt;<br /></pre><div><br /></div>This is how our view should look. LI elements will be created dynamically based on <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">options</span>&nbsp;property. The only thing we need to decide is how to implement inserting of <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">optionsCaption</span>&nbsp;dummy item before <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">options</span>&nbsp;in the dropdown. There are two ways for that. First one is to implement the logic in viewmodel: get <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">options</span>&nbsp;array and insert a new element there which will have <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">optionsText</span>&nbsp;as text, -1 as value. And in the view we can use simple <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">for</span>&nbsp;binding to iterate through the items and create <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">li</span>&nbsp;elements for each of them.<br />Second one is to create a <a href="http://knockoutjs.com/documentation/custom-bindings.html" target="_blank">custom binding</a>&nbsp;similar to out-of-the-box <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">options</span>&nbsp;binding.<br />I selected the second option to practice in custom bindings.<br />Let's call the binding class as <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">MsDropdownOptions</span>&nbsp;and put it in /webparts/depProps/bindings/MsDropdownOptions.ts: <br /><pre class="brush: typescript;">import * as ko from 'knockout';<br />/**<br /> * Knockout 'msoptions' binding.<br /> * Allows to bind Fabric UI dropdown options in the similar way to standard select options binding<br /> */<br />class MsDropdownOptions {<br />  constructor() {<br />    this.init = this.init.bind(this);<br />    this.update = this.update.bind(this);<br />  }<br /><br />  /**<br />   * This will be called when the binding is first applied to an element<br />   */<br />  public init(element: any, valueAccessor: () =&gt; any, allBindingsAccessor?: KnockoutAllBindingsAccessor, viewModel?: any, bindingContext?: KnockoutBindingContext): void | { controlsDescendantBindings: boolean; } {<br />    // check if binding is applied to the correct element<br />    if (element.tagName.toLowerCase() !== 'div' || element.className.indexOf('ms-Dropdown') === -1)<br />      throw new Error('msoptions binding applies only to &lt;div class="ms-Dropdown"&gt; elements');<br /><br />    // removing previous content if any<br />    this.removePreviousContent(element);<br /><br />    return { 'controlsDescendantBindings': true };<br />  }<br />  /**<br />   * Removes previous content of dropdown<br />   */<br />  private removePreviousContent(element: any) {<br />    const titleEl: HTMLSpanElement = element.querySelector('span');<br />    if (titleEl) {<br />      titleEl.textContent = '';<br />    }<br /><br />    const listEl = element.querySelector('ul');<br />    if (!listEl)<br />      throw new Error('Incorrect markup in ms-Dropdown element');<br /><br />    while (listEl.children.length) {<br />      listEl.children[0].remove();<br />    }<br />  }<br /><br />  /**<br />   * This method adds all the options and also updates selected item and text<br />   */<br />  private addNewContent(element: any, options: {}[], selectedValue: KnockoutObservable&lt;string&gt;, itemSelected: (evt: MouseEvent) =&gt; any): void {<br />    const titleEl: HTMLSpanElement = element.querySelector('span');<br />    const listEl = element.querySelector('ul');<br />    let selectedValueUnwrapped: string = selectedValue &amp;&amp; ko.utils.unwrapObservable(selectedValue);<br />    let selectedValueChanged: boolean = false;<br /><br />    if (!listEl || !titleEl)<br />      throw new Error('Incorrect markup in ms-Dropdown element');<br /><br />    for (let i: number = 0, len: number = options.length; i &lt; len; i++) {<br />      const liEl: HTMLLIElement = document.createElement('li');<br />      const option = options[i];<br />      liEl.textContent = option['text'];<br />      liEl.setAttribute('aria-value', option['value']);<br />      liEl.setAttribute('role', 'option');<br />      liEl.setAttribute('aria-text', option['text']);<br />      liEl.className = 'ms-Dropdown-item';<br /><br />      let isSelected: boolean = false;<br /><br />      if (selectedValueUnwrapped &amp;&amp; selectedValueUnwrapped === option['value'])<br />        isSelected = true;<br />      else {<br />        isSelected = option['selected'] === true || option['selected'] === true || option['selected'] === 'selected';<br />        if (isSelected) {<br />          selectedValueUnwrapped = option['value'];<br />          selectedValueChanged = true;<br />        }<br />      }<br /><br />      liEl.setAttribute('aria-selected', isSelected + '');<br /><br />      if (isSelected) {<br />        titleEl.textContent = option['text'];<br />        liEl.className += ' is-selected';<br />      }<br /><br />      if (itemSelected) {<br />        liEl.addEventListener('click', itemSelected); // itemSelected is provided from binding as well<br />      }<br /><br />      listEl.appendChild(liEl);<br />    }<br /><br />    if (!titleEl.textContent &amp;&amp; options.length &gt; 0) {<br />      titleEl.textContent = options[0]['text'];<br />      listEl.children[0].setAttribute('aria-selected', 'true');<br />      selectedValueUnwrapped = options[0]['value'];<br />      selectedValueChanged = true;<br />    }<br /><br />    if (selectedValueChanged &amp;&amp; selectedValue)<br />      selectedValue(selectedValueUnwrapped);<br />  }<br /><br />  /**<br />   * This will be called once when the binding is first applied to an element,<br />   * and again whenever any observables/computeds that are accessed change<br />   */<br />  public update(element: any, valueAccessor: () =&gt; any, allBindingsAccessor?: KnockoutAllBindingsAccessor,<br />    viewModel?: any, bindingContext?: KnockoutBindingContext): void {<br />    this.removePreviousContent(element);<br /><br />    let unwrappedArray: any = ko.utils.unwrapObservable(valueAccessor());<br />    let captionValue: any;<br />    let filteredArray: {}[] = [];<br />    let itemSelected: (evt: MouseEvent) =&gt; any;<br /><br />    if (unwrappedArray) {<br />      if (typeof unwrappedArray.length == "undefined") // Coerce single value into array<br />        unwrappedArray = [unwrappedArray];<br /><br />      // Filter out any entries marked as destroyed<br />      filteredArray = ko.utils.arrayFilter(unwrappedArray, (item) =&gt; {<br />        return item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);<br />      });<br /><br />      // If caption is included, add it to the array<br />      if (allBindingsAccessor['has']('optionsCaption')) {<br />        captionValue = ko.utils.unwrapObservable(allBindingsAccessor.get('optionsCaption'));<br />        // If caption value is null or undefined, don't show a caption<br />        if (captionValue !== null &amp;&amp; captionValue !== undefined) {<br />          filteredArray.unshift({ value: "-1", text: captionValue });<br />        }<br />      }<br />    } else {<br />      // If a falsy value is provided (e.g. null), we'll simply empty the select element<br />    }<br /><br />    if (allBindingsAccessor['has']('itemSelected'))<br />      itemSelected = allBindingsAccessor.get('itemSelected') as (evt: MouseEvent) =&gt; any;<br />    this.addNewContent(element, filteredArray, allBindingsAccessor.get('value'), itemSelected);<br />  }<br />}<br /></pre>Also we need to register this binding inside knockout. For that we need to extend <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">KnockoutBindingHandlers</span>&nbsp;interface definition with a new property (/webparts/depProps/bindings/bindings.d.ts): <br /><pre class="brush: typescript;">/// <reference path="../../../../typings/knockout/knockout.d.ts"><br />interface KnockoutBindingHandlers {<br />  msoptions: KnockoutBindingHandler; // custom binding for Knockout Fabric UI dropdown options<br />}<br /></reference></pre><br />And also we'll create a function that will register our custom binding (/webparts/depProps/bindings/MsDropdownOptions.ts): <br /><pre class="brush: typescript;">/**<br /> * This API adds custom 'msoptions' binding to Knockout bindingHandlers object<br /> */<br />export function addMsDropdownBindingHandler(): void {<br />  if (!ko.bindingHandlers.msoptions)<br />    ko.bindingHandlers.msoptions = new MsDropdownOptions();<br />}<br /></pre>Now we can use this binging in our view. So the final markup with bindings (based on Office UI Fabric Dropdown markup) will look like (/webparts/depProps/components/dropdown/view.ts): <br /><pre class="brush: typescript;">/**<br /> * Dropdown markup (Fabric UI style)<br /> */<br />export default class DrowdownView {<br />  public static templateHtml: string = `<br />    &lt;div&gt;<br />      &lt;label class="ms-label" data-bind="text: optionsCaption"&gt;&lt;/label&gt;<br />      &lt;div class="ms-Dropdown" data-bind="click: onOpenDropdown, msoptions: options, optionsCaption: optionsCaption, value: value, itemSelected: onItemSelected, css: { 'is-open': isOpen(), 'is-disabled': disabled() }"&gt;<br />        &lt;span class="ms-Dropdown-title" data-bind=""&gt;&lt;/span&gt;<br />        &lt;i class="ms-Dropdown-caretDown ms-Icon ms-Icon--ChevronDown"&gt;&lt;/i&gt;<br />        &lt;ul class="ms-Dropdown-items" role="listbox"&gt;<br />        &lt;/ul&gt;<br />      &lt;/div&gt;<br />    &lt;/div&gt;<br />  `;<br />}<br /></pre><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">msoptions, optionsCaption</span>&nbsp;and <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">itemSelected</span>&nbsp;parameters are handled inside created custom binding.<br /><br />As you can see there are some methods in the binding (<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">onOpenDropdown, onItemSelected, isOpen, disabled</span>). All these methods should be implemented in a viewmodel. So let's create the viewmodel (/webpars/depProps/components/dropdown/viewmodel.ts). <br /><pre class="brush: typescript;">import * as ko from 'knockout';<br /><br />/**<br /> * ViewModel of custom Dropdown component<br /> */<br />export class DropdownViewModel {<br />  /**<br />   * Last opened Dropdown ViewModel<br />   */<br />  private static _openedDropdownVM: DropdownViewModel;<br />  /**<br />   * Component initial parameters<br />   */<br />  private _params: IDropdownViewModelParams;<br /><br />  /**<br />   * Dropdown options<br />   */<br />  protected options: KnockoutObservableArray&lt;IDropdownOption&gt;;<br />  /**<br />   * Options caption<br />   */<br />  protected optionsCaption: string;<br />  /**<br />   * Current selected value<br />   */<br />  protected value: KnockoutObservable&lt;string&gt;;<br />  /**<br />   * Is Dropdown opened<br />   */<br />  protected isOpen: KnockoutObservable&lt;boolean&gt;;<br /><br />  /**<br />   * Is Dropdown disabled<br />   */<br />  protected disabled: KnockoutObservable&lt;boolean&gt;;<br /><br />  /**<br />   * ctor<br />   */<br />  constructor(params: IDropdownViewModelParams) {<br />    this._params = params;<br />    this.options = params.options;<br />    this.optionsCaption = params.optionsCaption;<br />    this.value = params.value;<br /><br />    if (params.disabled)<br />      this.disabled = params.disabled;<br />    else<br />      this.disabled = ko.observable&lt;boolean&gt;(false);<br /><br />    // initally dropdown is closed<br />    this.isOpen = ko.observable&lt;boolean&gt;(false);<br /><br />    //<br />    // binding all handlers to current instance<br />    //<br />    this.onItemSelected = this.onItemSelected.bind(this);<br />    this.onOpenDropdown = this.onOpenDropdown.bind(this);<br />    this._onDocClick = this._onDocClick.bind(this);<br />  }<br /><br />  /**<br />   * item selected handler<br />   */<br />  public onItemSelected(evt: MouseEvent) {<br />    var selectedItem = evt.srcElement;<br />    this.value(selectedItem.getAttribute('aria-value'));<br />  }<br /><br />  /**<br />   * Open-close dropdown handler<br />   */<br />  public onOpenDropdown(vm: DropdownViewModel, evt: MouseEvent) {<br />    if (this.disabled())<br />      return;<br />    const isOpen: boolean = ko.utils.unwrapObservable(this.isOpen);<br />    evt.stopPropagation();<br />    this.isOpen(!isOpen);<br /><br />    if (!isOpen) {<br />      if (DropdownViewModel._openedDropdownVM &amp;&amp; DropdownViewModel._openedDropdownVM !== this) {<br />        DropdownViewModel._openedDropdownVM._onDocClick(null);<br />      }<br /><br />      DropdownViewModel._openedDropdownVM = this;<br />      document.addEventListener('click', this._onDocClick);<br />    }<br />  }<br /><br />  /**<br />   * document.onclick handler<br />   */<br />  private _onDocClick(evt: MouseEvent) {<br />    this.isOpen(false);<br />    document.removeEventListener('click', this._onDocClick);<br />  }<br />}<br /></pre>Now register it (/webparts/depProps/components/dropdown/Dropdown.ts): <br /><pre class="brush: typescript;">import DropdownView from './view';<br />import { DropdownViewModel } from './viewmodel';<br />import * as ko from 'knockout';<br />import { addMsDropdownBindingHandler } from '../../bindings/MsDropdownOptions';<br /><br />/**<br /> * custom dropdown component name<br /> */<br />export const DROPDOWN_COMPONENT: string = 'spfx_dropdown';<br /><br />/**<br /> * API to register custom dropdown component<br /> */<br />export function registerDropdown(): boolean {<br />  if (!ko.bindingHandlers.msoptions)<br />    addMsDropdownBindingHandler();<br /><br />  if (!ko.components.isRegistered(DROPDOWN_COMPONENT)) {<br />    ko.components.register(DROPDOWN_COMPONENT, {<br />      template: DropdownView.templateHtml,<br />      viewModel: DropdownViewModel<br />    });<br />  }<br /><br />  return true;<br />}<br /></pre><br />And finally use it in our custom Property Pane field. For that:<br /><ul><li>import component name in&nbsp;PropertyPaneViewSelectorView.ts<br /><pre class="brush: typescript;">import { DROPDOWN_COMPONENT } from '../components/dropdown/Dropdown';<br /></pre></li><li>change the <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">_template</span>&nbsp;variable of <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">PropertyPaneViewSelectorView</span>&nbsp;class to:<br /><pre class="brush: typescript;">private _template: string = `<br />    &lt;div class="view-selector-component"&gt;<br />      &lt;${DROPDOWN_COMPONENT} params="options: lists, optionsCaption: listLabel, value: currentList"&gt;&lt;/${DROPDOWN_COMPONENT}&gt;<br />      &lt;${DROPDOWN_COMPONENT} params="options: views, optionsCaption: viewLabel, value: currentView, disabled: noListSelection"&gt;&lt;/${DROPDOWN_COMPONENT}&gt;<br />    &lt;/div&gt;<br />  `;<br /></pre></li><li>and change <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">PropertyPaneViewSelector</span>&nbsp;class to register the component in constructor:<br /><pre class="brush: typescript;">// somewhere at the beginning of the file<br />import { registerDropdown } from '../components/dropdown/Dropdown';<br /><br />/**<br /> * ctor<br /> */<br /> public constructor(_targetProperty: string, _properties: IPropertyPaneViewSelectorFieldPropsInternal) {<br />   // add this to the end of the constructor method<br />   // registering used custom Knockout components (dropdown)<br />   this._registerComponents();<br /> }<br /><br />/**<br /> * Registers used custom Knockout components<br /> */<br />private _registerComponents(): void {<br />  registerDropdown();<br />}<br /></pre></li></ul><div>Now we finished and can enjoy our beautiful custom Property Pane Field with Office UI Fabric-like dropdowns:<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-Mb84Wa0VonE/WBLeSBK3xxI/AAAAAAAAAak/8YRYbJZhwVoyBHk-gG61Wpx5pJt5MyyawCLcB/s1600/Screen%2BShot%2B2016-10-27%2Bat%2B10.12.18%2BPM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="https://4.bp.blogspot.com/-Mb84Wa0VonE/WBLeSBK3xxI/AAAAAAAAAak/8YRYbJZhwVoyBHk-gG61Wpx5pJt5MyyawCLcB/s400/Screen%2BShot%2B2016-10-27%2Bat%2B10.12.18%2BPM.png" width="352" /></a></div>Let me know if you have any questions or comments.<br /><br />Have fun!</div></div>